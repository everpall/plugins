#!/bin/bash
#
# This file was automatically generated by s2e-env at 2019-08-13 13:39:17.754256
#
# This bootstrap script is used to control the execution of the target program
# in an S2E guest VM.
#
# When you run launch-s2e.sh, the guest VM calls s2eget to fetch and execute
# this bootstrap script. This bootstrap script and the S2E config file
# determine how the target program is analyzed.
#

set -x

# To save the hassle of rebuilding guest images every time you update S2E's guest tools,
# the first thing that we do is get the latest versions of the guest tools.
function update_guest_tools {
    local GUEST_TOOLS
    local OUR_S2EGET

    GUEST_TOOLS="$COMMON_TOOLS $(target_tools)"
    OUR_S2EGET=${S2EGET}


    # Windows does not allow s2eget.exe to overwrite itself, so we need a workaround.
    if echo ${GUEST_TOOLS} | grep -q s2eget; then
      OUR_S2EGET=${S2EGET}_old.exe
      mv ${S2EGET} ${OUR_S2EGET}
    fi


    for TOOL in ${GUEST_TOOLS}; do

        # s2ecmd is used to create symbolic data, which in 64-bit guests may lead
        # to forced concretizations if it flows into MMX registers. Use 32-bit version
        # to minimize this problem.
        if [[ $TOOL == s2ecmd* ]]; then
            ${OUR_S2EGET} guest-tools32/${TOOL}
        else
            ${OUR_S2EGET} guest-tools/${TOOL}
        fi

        chmod +x ${TOOL}
    done
}

function prepare_target {
    # Make sure that the target is executable
    chmod +x "$1"
}


# This prepares the symbolic file inputs.
# This function takes as input an optional seed file name.
# If the seed file is present, the commands makes the seed symbolic.
# Otherwise, it creates an empty file.
#
# Symbolic files must be stored in a ram disk, as only memory (and cpu)
# is capable of holding symbolic data.
#
# This function prints the path to the symbolic file on stdout.
function prepare_inputs {
    local SYMB_FILE
	local symrangefile
	local symrangefile2
    SYMB_FILE="x:\\input.pct"
	symrangefile="step3_560.pct.symranges"
	symrangefile2="step3_560.pct"

    # The symbolic file will be split into symbolic variables of up to 4k bytes each.
    /c/Python27/python.exe -c "fp = open(\"${SYMB_FILE}\", 'wb'); fp.write('\x00'*560)"
    ${S2EGET} ${symrangefile} >/dev/null
    ${S2EGET} ${symrangefile2} >/dev/null
    export S2E_SYMFILE_RANGES="${symrangefile}"

    ${S2ECMD} symbfile 4096 ${SYMB_FILE} >/dev/null

    echo ${SYMB_FILE}
}


# This function executes the target program given in arguments.
#
# There are two versions of this function:
#    - without seed support
#    - with seed support (-s argument when creating projects with s2e_env)
function execute {
    local TARGET
    local SEED_FILE
    local SYMB_FILE

    TARGET=$1

    prepare_target "${TARGET}"



    SYMB_FILE="$(prepare_inputs)"

    execute_target "${TARGET}" "${SYMB_FILE}"

}

###############################################################################
# This section contains target-specific code

function make_seeds_symbolic {
    echo 1
}

# This function executes the target program.
# You can customize it if your program needs special invocation,
# custom symbolic arguments, etc.
function execute_target {
    local TARGET
    local SYMB_FILE

    TARGET="$1"
    SYMB_FILE="$2"
	cmd
	timeout 1000000

    ./${TARGET} ${SYMB_FILE} > /dev/null 2> /dev/null
}

# In 64-bit mode, it is important to run commands using the 64-bit cmd.exe,
# otherwise most changes will be confined to the SysWow64 environment.
# This function takes care of calling the right cmd.exe depending on the guest OS.
function run_cmd {
    local PREFIX
    local CMD
    CMD="$1"


    # The driver must be installed by a 64-bit process, otherwise
    # its files are copied into syswow64.
    # We use /c/Windows/sysnative to access 64-bit apps from 32-bit msys.
    PREFIX=/c/Windows/sysnative/


    ${PREFIX}cmd.exe '\/c' "${CMD}"
}

function install_driver {
    local PREFIX
    local DRIVER
    DRIVER="$1"

    run_cmd "rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 ${DRIVER}"
}

function target_init {
    # Set FaultInjectionEnabled to 1 if you want to test a driver for proper error recovery
    # This only initializes fault injection infrastructure. Actual activation will be done
    # later when needed using drvctl.exe.
    run_cmd "reg add HKLM\\Software\\S2E /v FaultInjectionEnabled /t REG_DWORD /d  0  /f"

    # Start the s2e.sys WindowsMonitor driver
    install_driver 'c:\s2e\s2e.inf'
    sc start s2e

    # Create ram disk
    imdisk -a -s 2M -m X: -p "/fs:fat /q /y"
    drvctl.exe register_debug
    drvctl.exe wait
}

function target_tools {
    echo "s2e.sys s2e.inf drvctl.exe"
}

# This function converts an msys path into a Windows path
function win_path {
  local dir="$(dirname "$1")"
  local fn="$(basename "$1")"
  echo "$(cd "$dir"; echo "$(pwd -W)/$fn")" | sed 's|/|\\|g';
}

S2ECMD=./s2ecmd.exe
S2EGET=./s2eget.exe
S2EPUT=./s2eput.exe
COMMON_TOOLS="s2ecmd.exe s2eget.exe s2eput.exe"

cd /c/s2e

###############################################################################


update_guest_tools



target_init

# Download the target file to analyze
${S2EGET} "test_symfile.exe"



# Run the analysis
execute "./test_symfile.exe"
